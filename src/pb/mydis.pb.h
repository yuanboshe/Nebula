// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mydis.proto

#ifndef PROTOBUF_INCLUDED_mydis_2eproto
#define PROTOBUF_INCLUDED_mydis_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mydis_2eproto 

namespace protobuf_mydis_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mydis_2eproto
namespace neb {
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class Mydis;
class MydisDefaultTypeInternal;
extern MydisDefaultTypeInternal _Mydis_default_instance_;
class Mydis_DbOperate;
class Mydis_DbOperateDefaultTypeInternal;
extern Mydis_DbOperateDefaultTypeInternal _Mydis_DbOperate_default_instance_;
class Mydis_DbOperate_Condition;
class Mydis_DbOperate_ConditionDefaultTypeInternal;
extern Mydis_DbOperate_ConditionDefaultTypeInternal _Mydis_DbOperate_Condition_default_instance_;
class Mydis_DbOperate_ConditionGroup;
class Mydis_DbOperate_ConditionGroupDefaultTypeInternal;
extern Mydis_DbOperate_ConditionGroupDefaultTypeInternal _Mydis_DbOperate_ConditionGroup_default_instance_;
class Mydis_DbOperate_OrderBy;
class Mydis_DbOperate_OrderByDefaultTypeInternal;
extern Mydis_DbOperate_OrderByDefaultTypeInternal _Mydis_DbOperate_OrderBy_default_instance_;
class Mydis_RedisOperate;
class Mydis_RedisOperateDefaultTypeInternal;
extern Mydis_RedisOperateDefaultTypeInternal _Mydis_RedisOperate_default_instance_;
class Record;
class RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Result_DataLocate;
class Result_DataLocateDefaultTypeInternal;
extern Result_DataLocateDefaultTypeInternal _Result_DataLocate_default_instance_;
}  // namespace neb
namespace google {
namespace protobuf {
template<> ::neb::Field* Arena::CreateMaybeMessage<::neb::Field>(Arena*);
template<> ::neb::Mydis* Arena::CreateMaybeMessage<::neb::Mydis>(Arena*);
template<> ::neb::Mydis_DbOperate* Arena::CreateMaybeMessage<::neb::Mydis_DbOperate>(Arena*);
template<> ::neb::Mydis_DbOperate_Condition* Arena::CreateMaybeMessage<::neb::Mydis_DbOperate_Condition>(Arena*);
template<> ::neb::Mydis_DbOperate_ConditionGroup* Arena::CreateMaybeMessage<::neb::Mydis_DbOperate_ConditionGroup>(Arena*);
template<> ::neb::Mydis_DbOperate_OrderBy* Arena::CreateMaybeMessage<::neb::Mydis_DbOperate_OrderBy>(Arena*);
template<> ::neb::Mydis_RedisOperate* Arena::CreateMaybeMessage<::neb::Mydis_RedisOperate>(Arena*);
template<> ::neb::Record* Arena::CreateMaybeMessage<::neb::Record>(Arena*);
template<> ::neb::Result* Arena::CreateMaybeMessage<::neb::Result>(Arena*);
template<> ::neb::Result_DataLocate* Arena::CreateMaybeMessage<::neb::Result_DataLocate>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace neb {

enum Mydis_RedisOperate_OPERATE_TYPE {
  Mydis_RedisOperate_OPERATE_TYPE_T_READ = 0,
  Mydis_RedisOperate_OPERATE_TYPE_T_WRITE = 1,
  Mydis_RedisOperate_OPERATE_TYPE_Mydis_RedisOperate_OPERATE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mydis_RedisOperate_OPERATE_TYPE_Mydis_RedisOperate_OPERATE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mydis_RedisOperate_OPERATE_TYPE_IsValid(int value);
const Mydis_RedisOperate_OPERATE_TYPE Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN = Mydis_RedisOperate_OPERATE_TYPE_T_READ;
const Mydis_RedisOperate_OPERATE_TYPE Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX = Mydis_RedisOperate_OPERATE_TYPE_T_WRITE;
const int Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE = Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mydis_RedisOperate_OPERATE_TYPE_descriptor();
inline const ::std::string& Mydis_RedisOperate_OPERATE_TYPE_Name(Mydis_RedisOperate_OPERATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mydis_RedisOperate_OPERATE_TYPE_descriptor(), value);
}
inline bool Mydis_RedisOperate_OPERATE_TYPE_Parse(
    const ::std::string& name, Mydis_RedisOperate_OPERATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mydis_RedisOperate_OPERATE_TYPE>(
    Mydis_RedisOperate_OPERATE_TYPE_descriptor(), name, value);
}
enum Mydis_DbOperate_Condition_E_RELATION {
  Mydis_DbOperate_Condition_E_RELATION_EQ = 0,
  Mydis_DbOperate_Condition_E_RELATION_NE = 1,
  Mydis_DbOperate_Condition_E_RELATION_GT = 2,
  Mydis_DbOperate_Condition_E_RELATION_LT = 3,
  Mydis_DbOperate_Condition_E_RELATION_GE = 4,
  Mydis_DbOperate_Condition_E_RELATION_LE = 5,
  Mydis_DbOperate_Condition_E_RELATION_LIKE = 6,
  Mydis_DbOperate_Condition_E_RELATION_IN = 7,
  Mydis_DbOperate_Condition_E_RELATION_Mydis_DbOperate_Condition_E_RELATION_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mydis_DbOperate_Condition_E_RELATION_Mydis_DbOperate_Condition_E_RELATION_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mydis_DbOperate_Condition_E_RELATION_IsValid(int value);
const Mydis_DbOperate_Condition_E_RELATION Mydis_DbOperate_Condition_E_RELATION_E_RELATION_MIN = Mydis_DbOperate_Condition_E_RELATION_EQ;
const Mydis_DbOperate_Condition_E_RELATION Mydis_DbOperate_Condition_E_RELATION_E_RELATION_MAX = Mydis_DbOperate_Condition_E_RELATION_IN;
const int Mydis_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE = Mydis_DbOperate_Condition_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mydis_DbOperate_Condition_E_RELATION_descriptor();
inline const ::std::string& Mydis_DbOperate_Condition_E_RELATION_Name(Mydis_DbOperate_Condition_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mydis_DbOperate_Condition_E_RELATION_descriptor(), value);
}
inline bool Mydis_DbOperate_Condition_E_RELATION_Parse(
    const ::std::string& name, Mydis_DbOperate_Condition_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mydis_DbOperate_Condition_E_RELATION>(
    Mydis_DbOperate_Condition_E_RELATION_descriptor(), name, value);
}
enum Mydis_DbOperate_ConditionGroup_E_RELATION {
  Mydis_DbOperate_ConditionGroup_E_RELATION_AND = 0,
  Mydis_DbOperate_ConditionGroup_E_RELATION_OR = 1,
  Mydis_DbOperate_ConditionGroup_E_RELATION_Mydis_DbOperate_ConditionGroup_E_RELATION_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mydis_DbOperate_ConditionGroup_E_RELATION_Mydis_DbOperate_ConditionGroup_E_RELATION_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mydis_DbOperate_ConditionGroup_E_RELATION_IsValid(int value);
const Mydis_DbOperate_ConditionGroup_E_RELATION Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN = Mydis_DbOperate_ConditionGroup_E_RELATION_AND;
const Mydis_DbOperate_ConditionGroup_E_RELATION Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX = Mydis_DbOperate_ConditionGroup_E_RELATION_OR;
const int Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE = Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mydis_DbOperate_ConditionGroup_E_RELATION_descriptor();
inline const ::std::string& Mydis_DbOperate_ConditionGroup_E_RELATION_Name(Mydis_DbOperate_ConditionGroup_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mydis_DbOperate_ConditionGroup_E_RELATION_descriptor(), value);
}
inline bool Mydis_DbOperate_ConditionGroup_E_RELATION_Parse(
    const ::std::string& name, Mydis_DbOperate_ConditionGroup_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mydis_DbOperate_ConditionGroup_E_RELATION>(
    Mydis_DbOperate_ConditionGroup_E_RELATION_descriptor(), name, value);
}
enum Mydis_DbOperate_OrderBy_E_RELATION {
  Mydis_DbOperate_OrderBy_E_RELATION_ASC = 0,
  Mydis_DbOperate_OrderBy_E_RELATION_DESC = 1,
  Mydis_DbOperate_OrderBy_E_RELATION_Mydis_DbOperate_OrderBy_E_RELATION_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mydis_DbOperate_OrderBy_E_RELATION_Mydis_DbOperate_OrderBy_E_RELATION_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mydis_DbOperate_OrderBy_E_RELATION_IsValid(int value);
const Mydis_DbOperate_OrderBy_E_RELATION Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN = Mydis_DbOperate_OrderBy_E_RELATION_ASC;
const Mydis_DbOperate_OrderBy_E_RELATION Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX = Mydis_DbOperate_OrderBy_E_RELATION_DESC;
const int Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE = Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mydis_DbOperate_OrderBy_E_RELATION_descriptor();
inline const ::std::string& Mydis_DbOperate_OrderBy_E_RELATION_Name(Mydis_DbOperate_OrderBy_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mydis_DbOperate_OrderBy_E_RELATION_descriptor(), value);
}
inline bool Mydis_DbOperate_OrderBy_E_RELATION_Parse(
    const ::std::string& name, Mydis_DbOperate_OrderBy_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mydis_DbOperate_OrderBy_E_RELATION>(
    Mydis_DbOperate_OrderBy_E_RELATION_descriptor(), name, value);
}
enum Mydis_DbOperate_E_QUERY_TYPE {
  Mydis_DbOperate_E_QUERY_TYPE_SELECT = 0,
  Mydis_DbOperate_E_QUERY_TYPE_INSERT = 1,
  Mydis_DbOperate_E_QUERY_TYPE_INSERT_IGNORE = 2,
  Mydis_DbOperate_E_QUERY_TYPE_UPDATE = 3,
  Mydis_DbOperate_E_QUERY_TYPE_REPLACE = 4,
  Mydis_DbOperate_E_QUERY_TYPE_DELETE = 5,
  Mydis_DbOperate_E_QUERY_TYPE_Mydis_DbOperate_E_QUERY_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mydis_DbOperate_E_QUERY_TYPE_Mydis_DbOperate_E_QUERY_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mydis_DbOperate_E_QUERY_TYPE_IsValid(int value);
const Mydis_DbOperate_E_QUERY_TYPE Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN = Mydis_DbOperate_E_QUERY_TYPE_SELECT;
const Mydis_DbOperate_E_QUERY_TYPE Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX = Mydis_DbOperate_E_QUERY_TYPE_DELETE;
const int Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE = Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mydis_DbOperate_E_QUERY_TYPE_descriptor();
inline const ::std::string& Mydis_DbOperate_E_QUERY_TYPE_Name(Mydis_DbOperate_E_QUERY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mydis_DbOperate_E_QUERY_TYPE_descriptor(), value);
}
inline bool Mydis_DbOperate_E_QUERY_TYPE_Parse(
    const ::std::string& name, Mydis_DbOperate_E_QUERY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mydis_DbOperate_E_QUERY_TYPE>(
    Mydis_DbOperate_E_QUERY_TYPE_descriptor(), name, value);
}
enum Result_E_RESULT_FROM {
  Result_E_RESULT_FROM_FROM_DB = 0,
  Result_E_RESULT_FROM_FROM_REDIS = 1,
  Result_E_RESULT_FROM_Result_E_RESULT_FROM_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Result_E_RESULT_FROM_Result_E_RESULT_FROM_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Result_E_RESULT_FROM_IsValid(int value);
const Result_E_RESULT_FROM Result_E_RESULT_FROM_E_RESULT_FROM_MIN = Result_E_RESULT_FROM_FROM_DB;
const Result_E_RESULT_FROM Result_E_RESULT_FROM_E_RESULT_FROM_MAX = Result_E_RESULT_FROM_FROM_REDIS;
const int Result_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE = Result_E_RESULT_FROM_E_RESULT_FROM_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_E_RESULT_FROM_descriptor();
inline const ::std::string& Result_E_RESULT_FROM_Name(Result_E_RESULT_FROM value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_E_RESULT_FROM_descriptor(), value);
}
inline bool Result_E_RESULT_FROM_Parse(
    const ::std::string& name, Result_E_RESULT_FROM* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result_E_RESULT_FROM>(
    Result_E_RESULT_FROM_descriptor(), name, value);
}
enum E_COL_TYPE {
  STRING = 0,
  INT = 1,
  BIGINT = 2,
  FLOAT = 3,
  DOUBLE = 4,
  E_COL_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  E_COL_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool E_COL_TYPE_IsValid(int value);
const E_COL_TYPE E_COL_TYPE_MIN = STRING;
const E_COL_TYPE E_COL_TYPE_MAX = DOUBLE;
const int E_COL_TYPE_ARRAYSIZE = E_COL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* E_COL_TYPE_descriptor();
inline const ::std::string& E_COL_TYPE_Name(E_COL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    E_COL_TYPE_descriptor(), value);
}
inline bool E_COL_TYPE_Parse(
    const ::std::string& name, E_COL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E_COL_TYPE>(
    E_COL_TYPE_descriptor(), name, value);
}
// ===================================================================

class Mydis_RedisOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Mydis.RedisOperate) */ {
 public:
  Mydis_RedisOperate();
  virtual ~Mydis_RedisOperate();

  Mydis_RedisOperate(const Mydis_RedisOperate& from);

  inline Mydis_RedisOperate& operator=(const Mydis_RedisOperate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mydis_RedisOperate(Mydis_RedisOperate&& from) noexcept
    : Mydis_RedisOperate() {
    *this = ::std::move(from);
  }

  inline Mydis_RedisOperate& operator=(Mydis_RedisOperate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mydis_RedisOperate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mydis_RedisOperate* internal_default_instance() {
    return reinterpret_cast<const Mydis_RedisOperate*>(
               &_Mydis_RedisOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Mydis_RedisOperate* other);
  friend void swap(Mydis_RedisOperate& a, Mydis_RedisOperate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mydis_RedisOperate* New() const final {
    return CreateMaybeMessage<Mydis_RedisOperate>(NULL);
  }

  Mydis_RedisOperate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mydis_RedisOperate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mydis_RedisOperate& from);
  void MergeFrom(const Mydis_RedisOperate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mydis_RedisOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mydis_RedisOperate_OPERATE_TYPE OPERATE_TYPE;
  static const OPERATE_TYPE T_READ =
    Mydis_RedisOperate_OPERATE_TYPE_T_READ;
  static const OPERATE_TYPE T_WRITE =
    Mydis_RedisOperate_OPERATE_TYPE_T_WRITE;
  static inline bool OPERATE_TYPE_IsValid(int value) {
    return Mydis_RedisOperate_OPERATE_TYPE_IsValid(value);
  }
  static const OPERATE_TYPE OPERATE_TYPE_MIN =
    Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN;
  static const OPERATE_TYPE OPERATE_TYPE_MAX =
    Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX;
  static const int OPERATE_TYPE_ARRAYSIZE =
    Mydis_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OPERATE_TYPE_descriptor() {
    return Mydis_RedisOperate_OPERATE_TYPE_descriptor();
  }
  static inline const ::std::string& OPERATE_TYPE_Name(OPERATE_TYPE value) {
    return Mydis_RedisOperate_OPERATE_TYPE_Name(value);
  }
  static inline bool OPERATE_TYPE_Parse(const ::std::string& name,
      OPERATE_TYPE* value) {
    return Mydis_RedisOperate_OPERATE_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .neb.Field fields = 5;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 5;
  ::neb::Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Field >*
      mutable_fields();
  const ::neb::Field& fields(int index) const;
  ::neb::Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
      fields() const;

  // bytes key_name = 1;
  void clear_key_name();
  static const int kKeyNameFieldNumber = 1;
  const ::std::string& key_name() const;
  void set_key_name(const ::std::string& value);
  #if LANG_CXX11
  void set_key_name(::std::string&& value);
  #endif
  void set_key_name(const char* value);
  void set_key_name(const void* value, size_t size);
  ::std::string* mutable_key_name();
  ::std::string* release_key_name();
  void set_allocated_key_name(::std::string* key_name);

  // string redis_cmd_read = 2;
  void clear_redis_cmd_read();
  static const int kRedisCmdReadFieldNumber = 2;
  const ::std::string& redis_cmd_read() const;
  void set_redis_cmd_read(const ::std::string& value);
  #if LANG_CXX11
  void set_redis_cmd_read(::std::string&& value);
  #endif
  void set_redis_cmd_read(const char* value);
  void set_redis_cmd_read(const char* value, size_t size);
  ::std::string* mutable_redis_cmd_read();
  ::std::string* release_redis_cmd_read();
  void set_allocated_redis_cmd_read(::std::string* redis_cmd_read);

  // string redis_cmd_write = 3;
  void clear_redis_cmd_write();
  static const int kRedisCmdWriteFieldNumber = 3;
  const ::std::string& redis_cmd_write() const;
  void set_redis_cmd_write(const ::std::string& value);
  #if LANG_CXX11
  void set_redis_cmd_write(::std::string&& value);
  #endif
  void set_redis_cmd_write(const char* value);
  void set_redis_cmd_write(const char* value, size_t size);
  ::std::string* mutable_redis_cmd_write();
  ::std::string* release_redis_cmd_write();
  void set_allocated_redis_cmd_write(::std::string* redis_cmd_write);

  // bytes hash_key = 9;
  void clear_hash_key();
  static const int kHashKeyFieldNumber = 9;
  const ::std::string& hash_key() const;
  void set_hash_key(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_key(::std::string&& value);
  #endif
  void set_hash_key(const char* value);
  void set_hash_key(const void* value, size_t size);
  ::std::string* mutable_hash_key();
  ::std::string* release_hash_key();
  void set_allocated_hash_key(::std::string* hash_key);

  // .neb.Mydis.RedisOperate.OPERATE_TYPE op_type = 4;
  void clear_op_type();
  static const int kOpTypeFieldNumber = 4;
  ::neb::Mydis_RedisOperate_OPERATE_TYPE op_type() const;
  void set_op_type(::neb::Mydis_RedisOperate_OPERATE_TYPE value);

  // int32 key_ttl = 6;
  void clear_key_ttl();
  static const int kKeyTtlFieldNumber = 6;
  ::google::protobuf::int32 key_ttl() const;
  void set_key_ttl(::google::protobuf::int32 value);

  // int32 redis_structure = 7;
  void clear_redis_structure();
  static const int kRedisStructureFieldNumber = 7;
  ::google::protobuf::int32 redis_structure() const;
  void set_redis_structure(::google::protobuf::int32 value);

  // int32 data_purpose = 8;
  void clear_data_purpose();
  static const int kDataPurposeFieldNumber = 8;
  ::google::protobuf::int32 data_purpose() const;
  void set_data_purpose(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:neb.Mydis.RedisOperate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::neb::Field > fields_;
  ::google::protobuf::internal::ArenaStringPtr key_name_;
  ::google::protobuf::internal::ArenaStringPtr redis_cmd_read_;
  ::google::protobuf::internal::ArenaStringPtr redis_cmd_write_;
  ::google::protobuf::internal::ArenaStringPtr hash_key_;
  int op_type_;
  ::google::protobuf::int32 key_ttl_;
  ::google::protobuf::int32 redis_structure_;
  ::google::protobuf::int32 data_purpose_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mydis_DbOperate_Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Mydis.DbOperate.Condition) */ {
 public:
  Mydis_DbOperate_Condition();
  virtual ~Mydis_DbOperate_Condition();

  Mydis_DbOperate_Condition(const Mydis_DbOperate_Condition& from);

  inline Mydis_DbOperate_Condition& operator=(const Mydis_DbOperate_Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mydis_DbOperate_Condition(Mydis_DbOperate_Condition&& from) noexcept
    : Mydis_DbOperate_Condition() {
    *this = ::std::move(from);
  }

  inline Mydis_DbOperate_Condition& operator=(Mydis_DbOperate_Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mydis_DbOperate_Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mydis_DbOperate_Condition* internal_default_instance() {
    return reinterpret_cast<const Mydis_DbOperate_Condition*>(
               &_Mydis_DbOperate_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Mydis_DbOperate_Condition* other);
  friend void swap(Mydis_DbOperate_Condition& a, Mydis_DbOperate_Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mydis_DbOperate_Condition* New() const final {
    return CreateMaybeMessage<Mydis_DbOperate_Condition>(NULL);
  }

  Mydis_DbOperate_Condition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mydis_DbOperate_Condition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mydis_DbOperate_Condition& from);
  void MergeFrom(const Mydis_DbOperate_Condition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mydis_DbOperate_Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mydis_DbOperate_Condition_E_RELATION E_RELATION;
  static const E_RELATION EQ =
    Mydis_DbOperate_Condition_E_RELATION_EQ;
  static const E_RELATION NE =
    Mydis_DbOperate_Condition_E_RELATION_NE;
  static const E_RELATION GT =
    Mydis_DbOperate_Condition_E_RELATION_GT;
  static const E_RELATION LT =
    Mydis_DbOperate_Condition_E_RELATION_LT;
  static const E_RELATION GE =
    Mydis_DbOperate_Condition_E_RELATION_GE;
  static const E_RELATION LE =
    Mydis_DbOperate_Condition_E_RELATION_LE;
  static const E_RELATION LIKE =
    Mydis_DbOperate_Condition_E_RELATION_LIKE;
  static const E_RELATION IN =
    Mydis_DbOperate_Condition_E_RELATION_IN;
  static inline bool E_RELATION_IsValid(int value) {
    return Mydis_DbOperate_Condition_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    Mydis_DbOperate_Condition_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    Mydis_DbOperate_Condition_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    Mydis_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return Mydis_DbOperate_Condition_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return Mydis_DbOperate_Condition_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return Mydis_DbOperate_Condition_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes col_values = 4;
  int col_values_size() const;
  void clear_col_values();
  static const int kColValuesFieldNumber = 4;
  const ::std::string& col_values(int index) const;
  ::std::string* mutable_col_values(int index);
  void set_col_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_col_values(int index, ::std::string&& value);
  #endif
  void set_col_values(int index, const char* value);
  void set_col_values(int index, const void* value, size_t size);
  ::std::string* add_col_values();
  void add_col_values(const ::std::string& value);
  #if LANG_CXX11
  void add_col_values(::std::string&& value);
  #endif
  void add_col_values(const char* value);
  void add_col_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& col_values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_col_values();

  // string col_name = 3;
  void clear_col_name();
  static const int kColNameFieldNumber = 3;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // string col_name_right = 5;
  void clear_col_name_right();
  static const int kColNameRightFieldNumber = 5;
  const ::std::string& col_name_right() const;
  void set_col_name_right(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name_right(::std::string&& value);
  #endif
  void set_col_name_right(const char* value);
  void set_col_name_right(const char* value, size_t size);
  ::std::string* mutable_col_name_right();
  ::std::string* release_col_name_right();
  void set_allocated_col_name_right(::std::string* col_name_right);

  // .neb.Mydis.DbOperate.Condition.E_RELATION relation = 1;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::neb::Mydis_DbOperate_Condition_E_RELATION relation() const;
  void set_relation(::neb::Mydis_DbOperate_Condition_E_RELATION value);

  // .neb.E_COL_TYPE col_type = 2;
  void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  ::neb::E_COL_TYPE col_type() const;
  void set_col_type(::neb::E_COL_TYPE value);

  // @@protoc_insertion_point(class_scope:neb.Mydis.DbOperate.Condition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> col_values_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::google::protobuf::internal::ArenaStringPtr col_name_right_;
  int relation_;
  int col_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mydis_DbOperate_ConditionGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Mydis.DbOperate.ConditionGroup) */ {
 public:
  Mydis_DbOperate_ConditionGroup();
  virtual ~Mydis_DbOperate_ConditionGroup();

  Mydis_DbOperate_ConditionGroup(const Mydis_DbOperate_ConditionGroup& from);

  inline Mydis_DbOperate_ConditionGroup& operator=(const Mydis_DbOperate_ConditionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mydis_DbOperate_ConditionGroup(Mydis_DbOperate_ConditionGroup&& from) noexcept
    : Mydis_DbOperate_ConditionGroup() {
    *this = ::std::move(from);
  }

  inline Mydis_DbOperate_ConditionGroup& operator=(Mydis_DbOperate_ConditionGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mydis_DbOperate_ConditionGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mydis_DbOperate_ConditionGroup* internal_default_instance() {
    return reinterpret_cast<const Mydis_DbOperate_ConditionGroup*>(
               &_Mydis_DbOperate_ConditionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Mydis_DbOperate_ConditionGroup* other);
  friend void swap(Mydis_DbOperate_ConditionGroup& a, Mydis_DbOperate_ConditionGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mydis_DbOperate_ConditionGroup* New() const final {
    return CreateMaybeMessage<Mydis_DbOperate_ConditionGroup>(NULL);
  }

  Mydis_DbOperate_ConditionGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mydis_DbOperate_ConditionGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mydis_DbOperate_ConditionGroup& from);
  void MergeFrom(const Mydis_DbOperate_ConditionGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mydis_DbOperate_ConditionGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mydis_DbOperate_ConditionGroup_E_RELATION E_RELATION;
  static const E_RELATION AND =
    Mydis_DbOperate_ConditionGroup_E_RELATION_AND;
  static const E_RELATION OR =
    Mydis_DbOperate_ConditionGroup_E_RELATION_OR;
  static inline bool E_RELATION_IsValid(int value) {
    return Mydis_DbOperate_ConditionGroup_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    Mydis_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return Mydis_DbOperate_ConditionGroup_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return Mydis_DbOperate_ConditionGroup_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return Mydis_DbOperate_ConditionGroup_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .neb.Mydis.DbOperate.Condition condition = 2;
  int condition_size() const;
  void clear_condition();
  static const int kConditionFieldNumber = 2;
  ::neb::Mydis_DbOperate_Condition* mutable_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_Condition >*
      mutable_condition();
  const ::neb::Mydis_DbOperate_Condition& condition(int index) const;
  ::neb::Mydis_DbOperate_Condition* add_condition();
  const ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_Condition >&
      condition() const;

  // .neb.Mydis.DbOperate.ConditionGroup.E_RELATION relation = 1;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION relation() const;
  void set_relation(::neb::Mydis_DbOperate_ConditionGroup_E_RELATION value);

  // @@protoc_insertion_point(class_scope:neb.Mydis.DbOperate.ConditionGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_Condition > condition_;
  int relation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mydis_DbOperate_OrderBy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Mydis.DbOperate.OrderBy) */ {
 public:
  Mydis_DbOperate_OrderBy();
  virtual ~Mydis_DbOperate_OrderBy();

  Mydis_DbOperate_OrderBy(const Mydis_DbOperate_OrderBy& from);

  inline Mydis_DbOperate_OrderBy& operator=(const Mydis_DbOperate_OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mydis_DbOperate_OrderBy(Mydis_DbOperate_OrderBy&& from) noexcept
    : Mydis_DbOperate_OrderBy() {
    *this = ::std::move(from);
  }

  inline Mydis_DbOperate_OrderBy& operator=(Mydis_DbOperate_OrderBy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mydis_DbOperate_OrderBy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mydis_DbOperate_OrderBy* internal_default_instance() {
    return reinterpret_cast<const Mydis_DbOperate_OrderBy*>(
               &_Mydis_DbOperate_OrderBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Mydis_DbOperate_OrderBy* other);
  friend void swap(Mydis_DbOperate_OrderBy& a, Mydis_DbOperate_OrderBy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mydis_DbOperate_OrderBy* New() const final {
    return CreateMaybeMessage<Mydis_DbOperate_OrderBy>(NULL);
  }

  Mydis_DbOperate_OrderBy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mydis_DbOperate_OrderBy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mydis_DbOperate_OrderBy& from);
  void MergeFrom(const Mydis_DbOperate_OrderBy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mydis_DbOperate_OrderBy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mydis_DbOperate_OrderBy_E_RELATION E_RELATION;
  static const E_RELATION ASC =
    Mydis_DbOperate_OrderBy_E_RELATION_ASC;
  static const E_RELATION DESC =
    Mydis_DbOperate_OrderBy_E_RELATION_DESC;
  static inline bool E_RELATION_IsValid(int value) {
    return Mydis_DbOperate_OrderBy_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    Mydis_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return Mydis_DbOperate_OrderBy_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return Mydis_DbOperate_OrderBy_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return Mydis_DbOperate_OrderBy_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string col_name = 2;
  void clear_col_name();
  static const int kColNameFieldNumber = 2;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // .neb.Mydis.DbOperate.OrderBy.E_RELATION relation = 1;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::neb::Mydis_DbOperate_OrderBy_E_RELATION relation() const;
  void set_relation(::neb::Mydis_DbOperate_OrderBy_E_RELATION value);

  // @@protoc_insertion_point(class_scope:neb.Mydis.DbOperate.OrderBy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  int relation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mydis_DbOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Mydis.DbOperate) */ {
 public:
  Mydis_DbOperate();
  virtual ~Mydis_DbOperate();

  Mydis_DbOperate(const Mydis_DbOperate& from);

  inline Mydis_DbOperate& operator=(const Mydis_DbOperate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mydis_DbOperate(Mydis_DbOperate&& from) noexcept
    : Mydis_DbOperate() {
    *this = ::std::move(from);
  }

  inline Mydis_DbOperate& operator=(Mydis_DbOperate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mydis_DbOperate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mydis_DbOperate* internal_default_instance() {
    return reinterpret_cast<const Mydis_DbOperate*>(
               &_Mydis_DbOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Mydis_DbOperate* other);
  friend void swap(Mydis_DbOperate& a, Mydis_DbOperate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mydis_DbOperate* New() const final {
    return CreateMaybeMessage<Mydis_DbOperate>(NULL);
  }

  Mydis_DbOperate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mydis_DbOperate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mydis_DbOperate& from);
  void MergeFrom(const Mydis_DbOperate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mydis_DbOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mydis_DbOperate_Condition Condition;
  typedef Mydis_DbOperate_ConditionGroup ConditionGroup;
  typedef Mydis_DbOperate_OrderBy OrderBy;

  typedef Mydis_DbOperate_E_QUERY_TYPE E_QUERY_TYPE;
  static const E_QUERY_TYPE SELECT =
    Mydis_DbOperate_E_QUERY_TYPE_SELECT;
  static const E_QUERY_TYPE INSERT =
    Mydis_DbOperate_E_QUERY_TYPE_INSERT;
  static const E_QUERY_TYPE INSERT_IGNORE =
    Mydis_DbOperate_E_QUERY_TYPE_INSERT_IGNORE;
  static const E_QUERY_TYPE UPDATE =
    Mydis_DbOperate_E_QUERY_TYPE_UPDATE;
  static const E_QUERY_TYPE REPLACE =
    Mydis_DbOperate_E_QUERY_TYPE_REPLACE;
  static const E_QUERY_TYPE DELETE =
    Mydis_DbOperate_E_QUERY_TYPE_DELETE;
  static inline bool E_QUERY_TYPE_IsValid(int value) {
    return Mydis_DbOperate_E_QUERY_TYPE_IsValid(value);
  }
  static const E_QUERY_TYPE E_QUERY_TYPE_MIN =
    Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN;
  static const E_QUERY_TYPE E_QUERY_TYPE_MAX =
    Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX;
  static const int E_QUERY_TYPE_ARRAYSIZE =
    Mydis_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_QUERY_TYPE_descriptor() {
    return Mydis_DbOperate_E_QUERY_TYPE_descriptor();
  }
  static inline const ::std::string& E_QUERY_TYPE_Name(E_QUERY_TYPE value) {
    return Mydis_DbOperate_E_QUERY_TYPE_Name(value);
  }
  static inline bool E_QUERY_TYPE_Parse(const ::std::string& name,
      E_QUERY_TYPE* value) {
    return Mydis_DbOperate_E_QUERY_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .neb.Field fields = 3;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 3;
  ::neb::Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Field >*
      mutable_fields();
  const ::neb::Field& fields(int index) const;
  ::neb::Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
      fields() const;

  // repeated .neb.Mydis.DbOperate.ConditionGroup conditions = 4;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 4;
  ::neb::Mydis_DbOperate_ConditionGroup* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_ConditionGroup >*
      mutable_conditions();
  const ::neb::Mydis_DbOperate_ConditionGroup& conditions(int index) const;
  ::neb::Mydis_DbOperate_ConditionGroup* add_conditions();
  const ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_ConditionGroup >&
      conditions() const;

  // repeated string groupby_col = 5;
  int groupby_col_size() const;
  void clear_groupby_col();
  static const int kGroupbyColFieldNumber = 5;
  const ::std::string& groupby_col(int index) const;
  ::std::string* mutable_groupby_col(int index);
  void set_groupby_col(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_groupby_col(int index, ::std::string&& value);
  #endif
  void set_groupby_col(int index, const char* value);
  void set_groupby_col(int index, const char* value, size_t size);
  ::std::string* add_groupby_col();
  void add_groupby_col(const ::std::string& value);
  #if LANG_CXX11
  void add_groupby_col(::std::string&& value);
  #endif
  void add_groupby_col(const char* value);
  void add_groupby_col(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& groupby_col() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groupby_col();

  // repeated .neb.Mydis.DbOperate.OrderBy orderby_col = 6;
  int orderby_col_size() const;
  void clear_orderby_col();
  static const int kOrderbyColFieldNumber = 6;
  ::neb::Mydis_DbOperate_OrderBy* mutable_orderby_col(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_OrderBy >*
      mutable_orderby_col();
  const ::neb::Mydis_DbOperate_OrderBy& orderby_col(int index) const;
  ::neb::Mydis_DbOperate_OrderBy* add_orderby_col();
  const ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_OrderBy >&
      orderby_col() const;

  // string table_name = 2;
  void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // .neb.Mydis.DbOperate.E_QUERY_TYPE query_type = 1;
  void clear_query_type();
  static const int kQueryTypeFieldNumber = 1;
  ::neb::Mydis_DbOperate_E_QUERY_TYPE query_type() const;
  void set_query_type(::neb::Mydis_DbOperate_E_QUERY_TYPE value);

  // .neb.Mydis.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
  void clear_group_relation();
  static const int kGroupRelationFieldNumber = 7;
  ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION group_relation() const;
  void set_group_relation(::neb::Mydis_DbOperate_ConditionGroup_E_RELATION value);

  // uint32 limit = 8;
  void clear_limit();
  static const int kLimitFieldNumber = 8;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // uint32 limit_from = 9;
  void clear_limit_from();
  static const int kLimitFromFieldNumber = 9;
  ::google::protobuf::uint32 limit_from() const;
  void set_limit_from(::google::protobuf::uint32 value);

  // uint32 mod_factor = 10;
  void clear_mod_factor();
  static const int kModFactorFieldNumber = 10;
  ::google::protobuf::uint32 mod_factor() const;
  void set_mod_factor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:neb.Mydis.DbOperate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::neb::Field > fields_;
  ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_ConditionGroup > conditions_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groupby_col_;
  ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_OrderBy > orderby_col_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  int query_type_;
  int group_relation_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 limit_from_;
  ::google::protobuf::uint32 mod_factor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mydis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Mydis) */ {
 public:
  Mydis();
  virtual ~Mydis();

  Mydis(const Mydis& from);

  inline Mydis& operator=(const Mydis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mydis(Mydis&& from) noexcept
    : Mydis() {
    *this = ::std::move(from);
  }

  inline Mydis& operator=(Mydis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mydis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mydis* internal_default_instance() {
    return reinterpret_cast<const Mydis*>(
               &_Mydis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Mydis* other);
  friend void swap(Mydis& a, Mydis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mydis* New() const final {
    return CreateMaybeMessage<Mydis>(NULL);
  }

  Mydis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mydis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mydis& from);
  void MergeFrom(const Mydis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mydis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mydis_RedisOperate RedisOperate;
  typedef Mydis_DbOperate DbOperate;

  // accessors -------------------------------------------------------

  // .neb.Mydis.RedisOperate redis_operate = 2;
  bool has_redis_operate() const;
  void clear_redis_operate();
  static const int kRedisOperateFieldNumber = 2;
  private:
  const ::neb::Mydis_RedisOperate& _internal_redis_operate() const;
  public:
  const ::neb::Mydis_RedisOperate& redis_operate() const;
  ::neb::Mydis_RedisOperate* release_redis_operate();
  ::neb::Mydis_RedisOperate* mutable_redis_operate();
  void set_allocated_redis_operate(::neb::Mydis_RedisOperate* redis_operate);

  // .neb.Mydis.DbOperate db_operate = 3;
  bool has_db_operate() const;
  void clear_db_operate();
  static const int kDbOperateFieldNumber = 3;
  private:
  const ::neb::Mydis_DbOperate& _internal_db_operate() const;
  public:
  const ::neb::Mydis_DbOperate& db_operate() const;
  ::neb::Mydis_DbOperate* release_db_operate();
  ::neb::Mydis_DbOperate* mutable_db_operate();
  void set_allocated_db_operate(::neb::Mydis_DbOperate* db_operate);

  // uint32 section_factor = 1;
  void clear_section_factor();
  static const int kSectionFactorFieldNumber = 1;
  ::google::protobuf::uint32 section_factor() const;
  void set_section_factor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:neb.Mydis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::neb::Mydis_RedisOperate* redis_operate_;
  ::neb::Mydis_DbOperate* db_operate_;
  ::google::protobuf::uint32 section_factor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(Record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Record* other);
  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return CreateMaybeMessage<Record>(NULL);
  }

  Record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .neb.Field field_info = 1;
  int field_info_size() const;
  void clear_field_info();
  static const int kFieldInfoFieldNumber = 1;
  ::neb::Field* mutable_field_info(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Field >*
      mutable_field_info();
  const ::neb::Field& field_info(int index) const;
  ::neb::Field* add_field_info();
  const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
      field_info() const;

  // @@protoc_insertion_point(class_scope:neb.Record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::neb::Field > field_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Field* other);
  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(NULL);
  }

  Field* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string col_name = 1;
  void clear_col_name();
  static const int kColNameFieldNumber = 1;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // bytes col_value = 3;
  void clear_col_value();
  static const int kColValueFieldNumber = 3;
  const ::std::string& col_value() const;
  void set_col_value(const ::std::string& value);
  #if LANG_CXX11
  void set_col_value(::std::string&& value);
  #endif
  void set_col_value(const char* value);
  void set_col_value(const void* value, size_t size);
  ::std::string* mutable_col_value();
  ::std::string* release_col_value();
  void set_allocated_col_value(::std::string* col_value);

  // string col_as = 4;
  void clear_col_as();
  static const int kColAsFieldNumber = 4;
  const ::std::string& col_as() const;
  void set_col_as(const ::std::string& value);
  #if LANG_CXX11
  void set_col_as(::std::string&& value);
  #endif
  void set_col_as(const char* value);
  void set_col_as(const char* value, size_t size);
  ::std::string* mutable_col_as();
  ::std::string* release_col_as();
  void set_allocated_col_as(::std::string* col_as);

  // .neb.E_COL_TYPE col_type = 2;
  void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  ::neb::E_COL_TYPE col_type() const;
  void set_col_type(::neb::E_COL_TYPE value);

  // @@protoc_insertion_point(class_scope:neb.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::google::protobuf::internal::ArenaStringPtr col_value_;
  ::google::protobuf::internal::ArenaStringPtr col_as_;
  int col_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Result_DataLocate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Result.DataLocate) */ {
 public:
  Result_DataLocate();
  virtual ~Result_DataLocate();

  Result_DataLocate(const Result_DataLocate& from);

  inline Result_DataLocate& operator=(const Result_DataLocate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Result_DataLocate(Result_DataLocate&& from) noexcept
    : Result_DataLocate() {
    *this = ::std::move(from);
  }

  inline Result_DataLocate& operator=(Result_DataLocate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Result_DataLocate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result_DataLocate* internal_default_instance() {
    return reinterpret_cast<const Result_DataLocate*>(
               &_Result_DataLocate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Result_DataLocate* other);
  friend void swap(Result_DataLocate& a, Result_DataLocate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Result_DataLocate* New() const final {
    return CreateMaybeMessage<Result_DataLocate>(NULL);
  }

  Result_DataLocate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Result_DataLocate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Result_DataLocate& from);
  void MergeFrom(const Result_DataLocate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result_DataLocate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 section_from = 1;
  void clear_section_from();
  static const int kSectionFromFieldNumber = 1;
  ::google::protobuf::uint32 section_from() const;
  void set_section_from(::google::protobuf::uint32 value);

  // uint32 section_to = 2;
  void clear_section_to();
  static const int kSectionToFieldNumber = 2;
  ::google::protobuf::uint32 section_to() const;
  void set_section_to(::google::protobuf::uint32 value);

  // uint32 hash = 3;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // uint32 divisor = 4;
  void clear_divisor();
  static const int kDivisorFieldNumber = 4;
  ::google::protobuf::uint32 divisor() const;
  void set_divisor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:neb.Result.DataLocate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 section_from_;
  ::google::protobuf::uint32 section_to_;
  ::google::protobuf::uint32 hash_;
  ::google::protobuf::uint32 divisor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Result* other);
  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(NULL);
  }

  Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Result_DataLocate DataLocate;

  typedef Result_E_RESULT_FROM E_RESULT_FROM;
  static const E_RESULT_FROM FROM_DB =
    Result_E_RESULT_FROM_FROM_DB;
  static const E_RESULT_FROM FROM_REDIS =
    Result_E_RESULT_FROM_FROM_REDIS;
  static inline bool E_RESULT_FROM_IsValid(int value) {
    return Result_E_RESULT_FROM_IsValid(value);
  }
  static const E_RESULT_FROM E_RESULT_FROM_MIN =
    Result_E_RESULT_FROM_E_RESULT_FROM_MIN;
  static const E_RESULT_FROM E_RESULT_FROM_MAX =
    Result_E_RESULT_FROM_E_RESULT_FROM_MAX;
  static const int E_RESULT_FROM_ARRAYSIZE =
    Result_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RESULT_FROM_descriptor() {
    return Result_E_RESULT_FROM_descriptor();
  }
  static inline const ::std::string& E_RESULT_FROM_Name(E_RESULT_FROM value) {
    return Result_E_RESULT_FROM_Name(value);
  }
  static inline bool E_RESULT_FROM_Parse(const ::std::string& name,
      E_RESULT_FROM* value) {
    return Result_E_RESULT_FROM_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .neb.Record record_data = 5;
  int record_data_size() const;
  void clear_record_data();
  static const int kRecordDataFieldNumber = 5;
  ::neb::Record* mutable_record_data(int index);
  ::google::protobuf::RepeatedPtrField< ::neb::Record >*
      mutable_record_data();
  const ::neb::Record& record_data(int index) const;
  ::neb::Record* add_record_data();
  const ::google::protobuf::RepeatedPtrField< ::neb::Record >&
      record_data() const;

  // bytes err_msg = 2;
  void clear_err_msg();
  static const int kErrMsgFieldNumber = 2;
  const ::std::string& err_msg() const;
  void set_err_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_err_msg(::std::string&& value);
  #endif
  void set_err_msg(const char* value);
  void set_err_msg(const void* value, size_t size);
  ::std::string* mutable_err_msg();
  ::std::string* release_err_msg();
  void set_allocated_err_msg(::std::string* err_msg);

  // .neb.Result.DataLocate locate = 7;
  bool has_locate() const;
  void clear_locate();
  static const int kLocateFieldNumber = 7;
  private:
  const ::neb::Result_DataLocate& _internal_locate() const;
  public:
  const ::neb::Result_DataLocate& locate() const;
  ::neb::Result_DataLocate* release_locate();
  ::neb::Result_DataLocate* mutable_locate();
  void set_allocated_locate(::neb::Result_DataLocate* locate);

  // int32 err_no = 1;
  void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  ::google::protobuf::int32 err_no() const;
  void set_err_no(::google::protobuf::int32 value);

  // int32 total_count = 3;
  void clear_total_count();
  static const int kTotalCountFieldNumber = 3;
  ::google::protobuf::int32 total_count() const;
  void set_total_count(::google::protobuf::int32 value);

  // int32 current_count = 4;
  void clear_current_count();
  static const int kCurrentCountFieldNumber = 4;
  ::google::protobuf::int32 current_count() const;
  void set_current_count(::google::protobuf::int32 value);

  // int32 from = 6;
  void clear_from();
  static const int kFromFieldNumber = 6;
  ::google::protobuf::int32 from() const;
  void set_from(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:neb.Result)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::neb::Record > record_data_;
  ::google::protobuf::internal::ArenaStringPtr err_msg_;
  ::neb::Result_DataLocate* locate_;
  ::google::protobuf::int32 err_no_;
  ::google::protobuf::int32 total_count_;
  ::google::protobuf::int32 current_count_;
  ::google::protobuf::int32 from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mydis_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Mydis_RedisOperate

// bytes key_name = 1;
inline void Mydis_RedisOperate::clear_key_name() {
  key_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_RedisOperate::key_name() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.key_name)
  return key_name_.GetNoArena();
}
inline void Mydis_RedisOperate::set_key_name(const ::std::string& value) {
  
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.key_name)
}
#if LANG_CXX11
inline void Mydis_RedisOperate::set_key_name(::std::string&& value) {
  
  key_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.RedisOperate.key_name)
}
#endif
inline void Mydis_RedisOperate::set_key_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.RedisOperate.key_name)
}
inline void Mydis_RedisOperate::set_key_name(const void* value, size_t size) {
  
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.RedisOperate.key_name)
}
inline ::std::string* Mydis_RedisOperate::mutable_key_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.RedisOperate.key_name)
  return key_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_RedisOperate::release_key_name() {
  // @@protoc_insertion_point(field_release:neb.Mydis.RedisOperate.key_name)
  
  return key_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_RedisOperate::set_allocated_key_name(::std::string* key_name) {
  if (key_name != NULL) {
    
  } else {
    
  }
  key_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.RedisOperate.key_name)
}

// string redis_cmd_read = 2;
inline void Mydis_RedisOperate::clear_redis_cmd_read() {
  redis_cmd_read_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_RedisOperate::redis_cmd_read() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.redis_cmd_read)
  return redis_cmd_read_.GetNoArena();
}
inline void Mydis_RedisOperate::set_redis_cmd_read(const ::std::string& value) {
  
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.redis_cmd_read)
}
#if LANG_CXX11
inline void Mydis_RedisOperate::set_redis_cmd_read(::std::string&& value) {
  
  redis_cmd_read_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.RedisOperate.redis_cmd_read)
}
#endif
inline void Mydis_RedisOperate::set_redis_cmd_read(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.RedisOperate.redis_cmd_read)
}
inline void Mydis_RedisOperate::set_redis_cmd_read(const char* value, size_t size) {
  
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.RedisOperate.redis_cmd_read)
}
inline ::std::string* Mydis_RedisOperate::mutable_redis_cmd_read() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.RedisOperate.redis_cmd_read)
  return redis_cmd_read_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_RedisOperate::release_redis_cmd_read() {
  // @@protoc_insertion_point(field_release:neb.Mydis.RedisOperate.redis_cmd_read)
  
  return redis_cmd_read_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_RedisOperate::set_allocated_redis_cmd_read(::std::string* redis_cmd_read) {
  if (redis_cmd_read != NULL) {
    
  } else {
    
  }
  redis_cmd_read_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redis_cmd_read);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.RedisOperate.redis_cmd_read)
}

// string redis_cmd_write = 3;
inline void Mydis_RedisOperate::clear_redis_cmd_write() {
  redis_cmd_write_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_RedisOperate::redis_cmd_write() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.redis_cmd_write)
  return redis_cmd_write_.GetNoArena();
}
inline void Mydis_RedisOperate::set_redis_cmd_write(const ::std::string& value) {
  
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.redis_cmd_write)
}
#if LANG_CXX11
inline void Mydis_RedisOperate::set_redis_cmd_write(::std::string&& value) {
  
  redis_cmd_write_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.RedisOperate.redis_cmd_write)
}
#endif
inline void Mydis_RedisOperate::set_redis_cmd_write(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.RedisOperate.redis_cmd_write)
}
inline void Mydis_RedisOperate::set_redis_cmd_write(const char* value, size_t size) {
  
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.RedisOperate.redis_cmd_write)
}
inline ::std::string* Mydis_RedisOperate::mutable_redis_cmd_write() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.RedisOperate.redis_cmd_write)
  return redis_cmd_write_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_RedisOperate::release_redis_cmd_write() {
  // @@protoc_insertion_point(field_release:neb.Mydis.RedisOperate.redis_cmd_write)
  
  return redis_cmd_write_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_RedisOperate::set_allocated_redis_cmd_write(::std::string* redis_cmd_write) {
  if (redis_cmd_write != NULL) {
    
  } else {
    
  }
  redis_cmd_write_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redis_cmd_write);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.RedisOperate.redis_cmd_write)
}

// .neb.Mydis.RedisOperate.OPERATE_TYPE op_type = 4;
inline void Mydis_RedisOperate::clear_op_type() {
  op_type_ = 0;
}
inline ::neb::Mydis_RedisOperate_OPERATE_TYPE Mydis_RedisOperate::op_type() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.op_type)
  return static_cast< ::neb::Mydis_RedisOperate_OPERATE_TYPE >(op_type_);
}
inline void Mydis_RedisOperate::set_op_type(::neb::Mydis_RedisOperate_OPERATE_TYPE value) {
  
  op_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.op_type)
}

// repeated .neb.Field fields = 5;
inline int Mydis_RedisOperate::fields_size() const {
  return fields_.size();
}
inline void Mydis_RedisOperate::clear_fields() {
  fields_.Clear();
}
inline ::neb::Field* Mydis_RedisOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.RedisOperate.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Field >*
Mydis_RedisOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.RedisOperate.fields)
  return &fields_;
}
inline const ::neb::Field& Mydis_RedisOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.fields)
  return fields_.Get(index);
}
inline ::neb::Field* Mydis_RedisOperate::add_fields() {
  // @@protoc_insertion_point(field_add:neb.Mydis.RedisOperate.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
Mydis_RedisOperate::fields() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.RedisOperate.fields)
  return fields_;
}

// int32 key_ttl = 6;
inline void Mydis_RedisOperate::clear_key_ttl() {
  key_ttl_ = 0;
}
inline ::google::protobuf::int32 Mydis_RedisOperate::key_ttl() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.key_ttl)
  return key_ttl_;
}
inline void Mydis_RedisOperate::set_key_ttl(::google::protobuf::int32 value) {
  
  key_ttl_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.key_ttl)
}

// int32 redis_structure = 7;
inline void Mydis_RedisOperate::clear_redis_structure() {
  redis_structure_ = 0;
}
inline ::google::protobuf::int32 Mydis_RedisOperate::redis_structure() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.redis_structure)
  return redis_structure_;
}
inline void Mydis_RedisOperate::set_redis_structure(::google::protobuf::int32 value) {
  
  redis_structure_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.redis_structure)
}

// int32 data_purpose = 8;
inline void Mydis_RedisOperate::clear_data_purpose() {
  data_purpose_ = 0;
}
inline ::google::protobuf::int32 Mydis_RedisOperate::data_purpose() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.data_purpose)
  return data_purpose_;
}
inline void Mydis_RedisOperate::set_data_purpose(::google::protobuf::int32 value) {
  
  data_purpose_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.data_purpose)
}

// bytes hash_key = 9;
inline void Mydis_RedisOperate::clear_hash_key() {
  hash_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_RedisOperate::hash_key() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.RedisOperate.hash_key)
  return hash_key_.GetNoArena();
}
inline void Mydis_RedisOperate::set_hash_key(const ::std::string& value) {
  
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.RedisOperate.hash_key)
}
#if LANG_CXX11
inline void Mydis_RedisOperate::set_hash_key(::std::string&& value) {
  
  hash_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.RedisOperate.hash_key)
}
#endif
inline void Mydis_RedisOperate::set_hash_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.RedisOperate.hash_key)
}
inline void Mydis_RedisOperate::set_hash_key(const void* value, size_t size) {
  
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.RedisOperate.hash_key)
}
inline ::std::string* Mydis_RedisOperate::mutable_hash_key() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.RedisOperate.hash_key)
  return hash_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_RedisOperate::release_hash_key() {
  // @@protoc_insertion_point(field_release:neb.Mydis.RedisOperate.hash_key)
  
  return hash_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_RedisOperate::set_allocated_hash_key(::std::string* hash_key) {
  if (hash_key != NULL) {
    
  } else {
    
  }
  hash_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_key);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.RedisOperate.hash_key)
}

// -------------------------------------------------------------------

// Mydis_DbOperate_Condition

// .neb.Mydis.DbOperate.Condition.E_RELATION relation = 1;
inline void Mydis_DbOperate_Condition::clear_relation() {
  relation_ = 0;
}
inline ::neb::Mydis_DbOperate_Condition_E_RELATION Mydis_DbOperate_Condition::relation() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.Condition.relation)
  return static_cast< ::neb::Mydis_DbOperate_Condition_E_RELATION >(relation_);
}
inline void Mydis_DbOperate_Condition::set_relation(::neb::Mydis_DbOperate_Condition_E_RELATION value) {
  
  relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.Condition.relation)
}

// .neb.E_COL_TYPE col_type = 2;
inline void Mydis_DbOperate_Condition::clear_col_type() {
  col_type_ = 0;
}
inline ::neb::E_COL_TYPE Mydis_DbOperate_Condition::col_type() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.Condition.col_type)
  return static_cast< ::neb::E_COL_TYPE >(col_type_);
}
inline void Mydis_DbOperate_Condition::set_col_type(::neb::E_COL_TYPE value) {
  
  col_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.Condition.col_type)
}

// string col_name = 3;
inline void Mydis_DbOperate_Condition::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_DbOperate_Condition::col_name() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.Condition.col_name)
  return col_name_.GetNoArena();
}
inline void Mydis_DbOperate_Condition::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.Condition.col_name)
}
#if LANG_CXX11
inline void Mydis_DbOperate_Condition::set_col_name(::std::string&& value) {
  
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.DbOperate.Condition.col_name)
}
#endif
inline void Mydis_DbOperate_Condition::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.DbOperate.Condition.col_name)
}
inline void Mydis_DbOperate_Condition::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.DbOperate.Condition.col_name)
}
inline ::std::string* Mydis_DbOperate_Condition::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.Condition.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_DbOperate_Condition::release_col_name() {
  // @@protoc_insertion_point(field_release:neb.Mydis.DbOperate.Condition.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_DbOperate_Condition::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.DbOperate.Condition.col_name)
}

// repeated bytes col_values = 4;
inline int Mydis_DbOperate_Condition::col_values_size() const {
  return col_values_.size();
}
inline void Mydis_DbOperate_Condition::clear_col_values() {
  col_values_.Clear();
}
inline const ::std::string& Mydis_DbOperate_Condition::col_values(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.Condition.col_values)
  return col_values_.Get(index);
}
inline ::std::string* Mydis_DbOperate_Condition::mutable_col_values(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.Condition.col_values)
  return col_values_.Mutable(index);
}
inline void Mydis_DbOperate_Condition::set_col_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.Condition.col_values)
  col_values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Mydis_DbOperate_Condition::set_col_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.Condition.col_values)
  col_values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Mydis_DbOperate_Condition::set_col_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:neb.Mydis.DbOperate.Condition.col_values)
}
inline void Mydis_DbOperate_Condition::set_col_values(int index, const void* value, size_t size) {
  col_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.DbOperate.Condition.col_values)
}
inline ::std::string* Mydis_DbOperate_Condition::add_col_values() {
  // @@protoc_insertion_point(field_add_mutable:neb.Mydis.DbOperate.Condition.col_values)
  return col_values_.Add();
}
inline void Mydis_DbOperate_Condition::add_col_values(const ::std::string& value) {
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.Condition.col_values)
}
#if LANG_CXX11
inline void Mydis_DbOperate_Condition::add_col_values(::std::string&& value) {
  col_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.Condition.col_values)
}
#endif
inline void Mydis_DbOperate_Condition::add_col_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:neb.Mydis.DbOperate.Condition.col_values)
}
inline void Mydis_DbOperate_Condition::add_col_values(const void* value, size_t size) {
  col_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:neb.Mydis.DbOperate.Condition.col_values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mydis_DbOperate_Condition::col_values() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.DbOperate.Condition.col_values)
  return col_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mydis_DbOperate_Condition::mutable_col_values() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.DbOperate.Condition.col_values)
  return &col_values_;
}

// string col_name_right = 5;
inline void Mydis_DbOperate_Condition::clear_col_name_right() {
  col_name_right_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_DbOperate_Condition::col_name_right() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.Condition.col_name_right)
  return col_name_right_.GetNoArena();
}
inline void Mydis_DbOperate_Condition::set_col_name_right(const ::std::string& value) {
  
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.Condition.col_name_right)
}
#if LANG_CXX11
inline void Mydis_DbOperate_Condition::set_col_name_right(::std::string&& value) {
  
  col_name_right_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.DbOperate.Condition.col_name_right)
}
#endif
inline void Mydis_DbOperate_Condition::set_col_name_right(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.DbOperate.Condition.col_name_right)
}
inline void Mydis_DbOperate_Condition::set_col_name_right(const char* value, size_t size) {
  
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.DbOperate.Condition.col_name_right)
}
inline ::std::string* Mydis_DbOperate_Condition::mutable_col_name_right() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.Condition.col_name_right)
  return col_name_right_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_DbOperate_Condition::release_col_name_right() {
  // @@protoc_insertion_point(field_release:neb.Mydis.DbOperate.Condition.col_name_right)
  
  return col_name_right_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_DbOperate_Condition::set_allocated_col_name_right(::std::string* col_name_right) {
  if (col_name_right != NULL) {
    
  } else {
    
  }
  col_name_right_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name_right);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.DbOperate.Condition.col_name_right)
}

// -------------------------------------------------------------------

// Mydis_DbOperate_ConditionGroup

// .neb.Mydis.DbOperate.ConditionGroup.E_RELATION relation = 1;
inline void Mydis_DbOperate_ConditionGroup::clear_relation() {
  relation_ = 0;
}
inline ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION Mydis_DbOperate_ConditionGroup::relation() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.ConditionGroup.relation)
  return static_cast< ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION >(relation_);
}
inline void Mydis_DbOperate_ConditionGroup::set_relation(::neb::Mydis_DbOperate_ConditionGroup_E_RELATION value) {
  
  relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.ConditionGroup.relation)
}

// repeated .neb.Mydis.DbOperate.Condition condition = 2;
inline int Mydis_DbOperate_ConditionGroup::condition_size() const {
  return condition_.size();
}
inline void Mydis_DbOperate_ConditionGroup::clear_condition() {
  condition_.Clear();
}
inline ::neb::Mydis_DbOperate_Condition* Mydis_DbOperate_ConditionGroup::mutable_condition(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.ConditionGroup.condition)
  return condition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_Condition >*
Mydis_DbOperate_ConditionGroup::mutable_condition() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.DbOperate.ConditionGroup.condition)
  return &condition_;
}
inline const ::neb::Mydis_DbOperate_Condition& Mydis_DbOperate_ConditionGroup::condition(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.ConditionGroup.condition)
  return condition_.Get(index);
}
inline ::neb::Mydis_DbOperate_Condition* Mydis_DbOperate_ConditionGroup::add_condition() {
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.ConditionGroup.condition)
  return condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_Condition >&
Mydis_DbOperate_ConditionGroup::condition() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.DbOperate.ConditionGroup.condition)
  return condition_;
}

// -------------------------------------------------------------------

// Mydis_DbOperate_OrderBy

// .neb.Mydis.DbOperate.OrderBy.E_RELATION relation = 1;
inline void Mydis_DbOperate_OrderBy::clear_relation() {
  relation_ = 0;
}
inline ::neb::Mydis_DbOperate_OrderBy_E_RELATION Mydis_DbOperate_OrderBy::relation() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.OrderBy.relation)
  return static_cast< ::neb::Mydis_DbOperate_OrderBy_E_RELATION >(relation_);
}
inline void Mydis_DbOperate_OrderBy::set_relation(::neb::Mydis_DbOperate_OrderBy_E_RELATION value) {
  
  relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.OrderBy.relation)
}

// string col_name = 2;
inline void Mydis_DbOperate_OrderBy::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_DbOperate_OrderBy::col_name() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.OrderBy.col_name)
  return col_name_.GetNoArena();
}
inline void Mydis_DbOperate_OrderBy::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.OrderBy.col_name)
}
#if LANG_CXX11
inline void Mydis_DbOperate_OrderBy::set_col_name(::std::string&& value) {
  
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.DbOperate.OrderBy.col_name)
}
#endif
inline void Mydis_DbOperate_OrderBy::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.DbOperate.OrderBy.col_name)
}
inline void Mydis_DbOperate_OrderBy::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.DbOperate.OrderBy.col_name)
}
inline ::std::string* Mydis_DbOperate_OrderBy::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.OrderBy.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_DbOperate_OrderBy::release_col_name() {
  // @@protoc_insertion_point(field_release:neb.Mydis.DbOperate.OrderBy.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_DbOperate_OrderBy::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.DbOperate.OrderBy.col_name)
}

// -------------------------------------------------------------------

// Mydis_DbOperate

// .neb.Mydis.DbOperate.E_QUERY_TYPE query_type = 1;
inline void Mydis_DbOperate::clear_query_type() {
  query_type_ = 0;
}
inline ::neb::Mydis_DbOperate_E_QUERY_TYPE Mydis_DbOperate::query_type() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.query_type)
  return static_cast< ::neb::Mydis_DbOperate_E_QUERY_TYPE >(query_type_);
}
inline void Mydis_DbOperate::set_query_type(::neb::Mydis_DbOperate_E_QUERY_TYPE value) {
  
  query_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.query_type)
}

// string table_name = 2;
inline void Mydis_DbOperate::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mydis_DbOperate::table_name() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.table_name)
  return table_name_.GetNoArena();
}
inline void Mydis_DbOperate::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.table_name)
}
#if LANG_CXX11
inline void Mydis_DbOperate::set_table_name(::std::string&& value) {
  
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Mydis.DbOperate.table_name)
}
#endif
inline void Mydis_DbOperate::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Mydis.DbOperate.table_name)
}
inline void Mydis_DbOperate::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.DbOperate.table_name)
}
inline ::std::string* Mydis_DbOperate::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mydis_DbOperate::release_table_name() {
  // @@protoc_insertion_point(field_release:neb.Mydis.DbOperate.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mydis_DbOperate::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.DbOperate.table_name)
}

// repeated .neb.Field fields = 3;
inline int Mydis_DbOperate::fields_size() const {
  return fields_.size();
}
inline void Mydis_DbOperate::clear_fields() {
  fields_.Clear();
}
inline ::neb::Field* Mydis_DbOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Field >*
Mydis_DbOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.DbOperate.fields)
  return &fields_;
}
inline const ::neb::Field& Mydis_DbOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.fields)
  return fields_.Get(index);
}
inline ::neb::Field* Mydis_DbOperate::add_fields() {
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
Mydis_DbOperate::fields() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.DbOperate.fields)
  return fields_;
}

// repeated .neb.Mydis.DbOperate.ConditionGroup conditions = 4;
inline int Mydis_DbOperate::conditions_size() const {
  return conditions_.size();
}
inline void Mydis_DbOperate::clear_conditions() {
  conditions_.Clear();
}
inline ::neb::Mydis_DbOperate_ConditionGroup* Mydis_DbOperate::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.conditions)
  return conditions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_ConditionGroup >*
Mydis_DbOperate::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.DbOperate.conditions)
  return &conditions_;
}
inline const ::neb::Mydis_DbOperate_ConditionGroup& Mydis_DbOperate::conditions(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.conditions)
  return conditions_.Get(index);
}
inline ::neb::Mydis_DbOperate_ConditionGroup* Mydis_DbOperate::add_conditions() {
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.conditions)
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_ConditionGroup >&
Mydis_DbOperate::conditions() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.DbOperate.conditions)
  return conditions_;
}

// repeated string groupby_col = 5;
inline int Mydis_DbOperate::groupby_col_size() const {
  return groupby_col_.size();
}
inline void Mydis_DbOperate::clear_groupby_col() {
  groupby_col_.Clear();
}
inline const ::std::string& Mydis_DbOperate::groupby_col(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.groupby_col)
  return groupby_col_.Get(index);
}
inline ::std::string* Mydis_DbOperate::mutable_groupby_col(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.groupby_col)
  return groupby_col_.Mutable(index);
}
inline void Mydis_DbOperate::set_groupby_col(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.groupby_col)
  groupby_col_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Mydis_DbOperate::set_groupby_col(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.groupby_col)
  groupby_col_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Mydis_DbOperate::set_groupby_col(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  groupby_col_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:neb.Mydis.DbOperate.groupby_col)
}
inline void Mydis_DbOperate::set_groupby_col(int index, const char* value, size_t size) {
  groupby_col_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:neb.Mydis.DbOperate.groupby_col)
}
inline ::std::string* Mydis_DbOperate::add_groupby_col() {
  // @@protoc_insertion_point(field_add_mutable:neb.Mydis.DbOperate.groupby_col)
  return groupby_col_.Add();
}
inline void Mydis_DbOperate::add_groupby_col(const ::std::string& value) {
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.groupby_col)
}
#if LANG_CXX11
inline void Mydis_DbOperate::add_groupby_col(::std::string&& value) {
  groupby_col_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.groupby_col)
}
#endif
inline void Mydis_DbOperate::add_groupby_col(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:neb.Mydis.DbOperate.groupby_col)
}
inline void Mydis_DbOperate::add_groupby_col(const char* value, size_t size) {
  groupby_col_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:neb.Mydis.DbOperate.groupby_col)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mydis_DbOperate::groupby_col() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.DbOperate.groupby_col)
  return groupby_col_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mydis_DbOperate::mutable_groupby_col() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.DbOperate.groupby_col)
  return &groupby_col_;
}

// repeated .neb.Mydis.DbOperate.OrderBy orderby_col = 6;
inline int Mydis_DbOperate::orderby_col_size() const {
  return orderby_col_.size();
}
inline void Mydis_DbOperate::clear_orderby_col() {
  orderby_col_.Clear();
}
inline ::neb::Mydis_DbOperate_OrderBy* Mydis_DbOperate::mutable_orderby_col(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Mydis.DbOperate.orderby_col)
  return orderby_col_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_OrderBy >*
Mydis_DbOperate::mutable_orderby_col() {
  // @@protoc_insertion_point(field_mutable_list:neb.Mydis.DbOperate.orderby_col)
  return &orderby_col_;
}
inline const ::neb::Mydis_DbOperate_OrderBy& Mydis_DbOperate::orderby_col(int index) const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.orderby_col)
  return orderby_col_.Get(index);
}
inline ::neb::Mydis_DbOperate_OrderBy* Mydis_DbOperate::add_orderby_col() {
  // @@protoc_insertion_point(field_add:neb.Mydis.DbOperate.orderby_col)
  return orderby_col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Mydis_DbOperate_OrderBy >&
Mydis_DbOperate::orderby_col() const {
  // @@protoc_insertion_point(field_list:neb.Mydis.DbOperate.orderby_col)
  return orderby_col_;
}

// .neb.Mydis.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
inline void Mydis_DbOperate::clear_group_relation() {
  group_relation_ = 0;
}
inline ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION Mydis_DbOperate::group_relation() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.group_relation)
  return static_cast< ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION >(group_relation_);
}
inline void Mydis_DbOperate::set_group_relation(::neb::Mydis_DbOperate_ConditionGroup_E_RELATION value) {
  
  group_relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.group_relation)
}

// uint32 limit = 8;
inline void Mydis_DbOperate::clear_limit() {
  limit_ = 0u;
}
inline ::google::protobuf::uint32 Mydis_DbOperate::limit() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.limit)
  return limit_;
}
inline void Mydis_DbOperate::set_limit(::google::protobuf::uint32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.limit)
}

// uint32 limit_from = 9;
inline void Mydis_DbOperate::clear_limit_from() {
  limit_from_ = 0u;
}
inline ::google::protobuf::uint32 Mydis_DbOperate::limit_from() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.limit_from)
  return limit_from_;
}
inline void Mydis_DbOperate::set_limit_from(::google::protobuf::uint32 value) {
  
  limit_from_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.limit_from)
}

// uint32 mod_factor = 10;
inline void Mydis_DbOperate::clear_mod_factor() {
  mod_factor_ = 0u;
}
inline ::google::protobuf::uint32 Mydis_DbOperate::mod_factor() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.DbOperate.mod_factor)
  return mod_factor_;
}
inline void Mydis_DbOperate::set_mod_factor(::google::protobuf::uint32 value) {
  
  mod_factor_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.DbOperate.mod_factor)
}

// -------------------------------------------------------------------

// Mydis

// uint32 section_factor = 1;
inline void Mydis::clear_section_factor() {
  section_factor_ = 0u;
}
inline ::google::protobuf::uint32 Mydis::section_factor() const {
  // @@protoc_insertion_point(field_get:neb.Mydis.section_factor)
  return section_factor_;
}
inline void Mydis::set_section_factor(::google::protobuf::uint32 value) {
  
  section_factor_ = value;
  // @@protoc_insertion_point(field_set:neb.Mydis.section_factor)
}

// .neb.Mydis.RedisOperate redis_operate = 2;
inline bool Mydis::has_redis_operate() const {
  return this != internal_default_instance() && redis_operate_ != NULL;
}
inline void Mydis::clear_redis_operate() {
  if (GetArenaNoVirtual() == NULL && redis_operate_ != NULL) {
    delete redis_operate_;
  }
  redis_operate_ = NULL;
}
inline const ::neb::Mydis_RedisOperate& Mydis::_internal_redis_operate() const {
  return *redis_operate_;
}
inline const ::neb::Mydis_RedisOperate& Mydis::redis_operate() const {
  const ::neb::Mydis_RedisOperate* p = redis_operate_;
  // @@protoc_insertion_point(field_get:neb.Mydis.redis_operate)
  return p != NULL ? *p : *reinterpret_cast<const ::neb::Mydis_RedisOperate*>(
      &::neb::_Mydis_RedisOperate_default_instance_);
}
inline ::neb::Mydis_RedisOperate* Mydis::release_redis_operate() {
  // @@protoc_insertion_point(field_release:neb.Mydis.redis_operate)
  
  ::neb::Mydis_RedisOperate* temp = redis_operate_;
  redis_operate_ = NULL;
  return temp;
}
inline ::neb::Mydis_RedisOperate* Mydis::mutable_redis_operate() {
  
  if (redis_operate_ == NULL) {
    auto* p = CreateMaybeMessage<::neb::Mydis_RedisOperate>(GetArenaNoVirtual());
    redis_operate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:neb.Mydis.redis_operate)
  return redis_operate_;
}
inline void Mydis::set_allocated_redis_operate(::neb::Mydis_RedisOperate* redis_operate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete redis_operate_;
  }
  if (redis_operate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      redis_operate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, redis_operate, submessage_arena);
    }
    
  } else {
    
  }
  redis_operate_ = redis_operate;
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.redis_operate)
}

// .neb.Mydis.DbOperate db_operate = 3;
inline bool Mydis::has_db_operate() const {
  return this != internal_default_instance() && db_operate_ != NULL;
}
inline void Mydis::clear_db_operate() {
  if (GetArenaNoVirtual() == NULL && db_operate_ != NULL) {
    delete db_operate_;
  }
  db_operate_ = NULL;
}
inline const ::neb::Mydis_DbOperate& Mydis::_internal_db_operate() const {
  return *db_operate_;
}
inline const ::neb::Mydis_DbOperate& Mydis::db_operate() const {
  const ::neb::Mydis_DbOperate* p = db_operate_;
  // @@protoc_insertion_point(field_get:neb.Mydis.db_operate)
  return p != NULL ? *p : *reinterpret_cast<const ::neb::Mydis_DbOperate*>(
      &::neb::_Mydis_DbOperate_default_instance_);
}
inline ::neb::Mydis_DbOperate* Mydis::release_db_operate() {
  // @@protoc_insertion_point(field_release:neb.Mydis.db_operate)
  
  ::neb::Mydis_DbOperate* temp = db_operate_;
  db_operate_ = NULL;
  return temp;
}
inline ::neb::Mydis_DbOperate* Mydis::mutable_db_operate() {
  
  if (db_operate_ == NULL) {
    auto* p = CreateMaybeMessage<::neb::Mydis_DbOperate>(GetArenaNoVirtual());
    db_operate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:neb.Mydis.db_operate)
  return db_operate_;
}
inline void Mydis::set_allocated_db_operate(::neb::Mydis_DbOperate* db_operate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete db_operate_;
  }
  if (db_operate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      db_operate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, db_operate, submessage_arena);
    }
    
  } else {
    
  }
  db_operate_ = db_operate;
  // @@protoc_insertion_point(field_set_allocated:neb.Mydis.db_operate)
}

// -------------------------------------------------------------------

// Record

// repeated .neb.Field field_info = 1;
inline int Record::field_info_size() const {
  return field_info_.size();
}
inline void Record::clear_field_info() {
  field_info_.Clear();
}
inline ::neb::Field* Record::mutable_field_info(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Record.field_info)
  return field_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Field >*
Record::mutable_field_info() {
  // @@protoc_insertion_point(field_mutable_list:neb.Record.field_info)
  return &field_info_;
}
inline const ::neb::Field& Record::field_info(int index) const {
  // @@protoc_insertion_point(field_get:neb.Record.field_info)
  return field_info_.Get(index);
}
inline ::neb::Field* Record::add_field_info() {
  // @@protoc_insertion_point(field_add:neb.Record.field_info)
  return field_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
Record::field_info() const {
  // @@protoc_insertion_point(field_list:neb.Record.field_info)
  return field_info_;
}

// -------------------------------------------------------------------

// Field

// string col_name = 1;
inline void Field::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::col_name() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_name)
  return col_name_.GetNoArena();
}
inline void Field::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Field.col_name)
}
#if LANG_CXX11
inline void Field::set_col_name(::std::string&& value) {
  
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Field.col_name)
}
#endif
inline void Field::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Field.col_name)
}
inline void Field::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Field.col_name)
}
inline ::std::string* Field::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Field.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_name() {
  // @@protoc_insertion_point(field_release:neb.Field.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Field.col_name)
}

// .neb.E_COL_TYPE col_type = 2;
inline void Field::clear_col_type() {
  col_type_ = 0;
}
inline ::neb::E_COL_TYPE Field::col_type() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_type)
  return static_cast< ::neb::E_COL_TYPE >(col_type_);
}
inline void Field::set_col_type(::neb::E_COL_TYPE value) {
  
  col_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Field.col_type)
}

// bytes col_value = 3;
inline void Field::clear_col_value() {
  col_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::col_value() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_value)
  return col_value_.GetNoArena();
}
inline void Field::set_col_value(const ::std::string& value) {
  
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Field.col_value)
}
#if LANG_CXX11
inline void Field::set_col_value(::std::string&& value) {
  
  col_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Field.col_value)
}
#endif
inline void Field::set_col_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Field.col_value)
}
inline void Field::set_col_value(const void* value, size_t size) {
  
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Field.col_value)
}
inline ::std::string* Field::mutable_col_value() {
  
  // @@protoc_insertion_point(field_mutable:neb.Field.col_value)
  return col_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_value() {
  // @@protoc_insertion_point(field_release:neb.Field.col_value)
  
  return col_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_value(::std::string* col_value) {
  if (col_value != NULL) {
    
  } else {
    
  }
  col_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_value);
  // @@protoc_insertion_point(field_set_allocated:neb.Field.col_value)
}

// string col_as = 4;
inline void Field::clear_col_as() {
  col_as_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::col_as() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_as)
  return col_as_.GetNoArena();
}
inline void Field::set_col_as(const ::std::string& value) {
  
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Field.col_as)
}
#if LANG_CXX11
inline void Field::set_col_as(::std::string&& value) {
  
  col_as_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Field.col_as)
}
#endif
inline void Field::set_col_as(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Field.col_as)
}
inline void Field::set_col_as(const char* value, size_t size) {
  
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Field.col_as)
}
inline ::std::string* Field::mutable_col_as() {
  
  // @@protoc_insertion_point(field_mutable:neb.Field.col_as)
  return col_as_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_as() {
  // @@protoc_insertion_point(field_release:neb.Field.col_as)
  
  return col_as_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_as(::std::string* col_as) {
  if (col_as != NULL) {
    
  } else {
    
  }
  col_as_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_as);
  // @@protoc_insertion_point(field_set_allocated:neb.Field.col_as)
}

// -------------------------------------------------------------------

// Result_DataLocate

// uint32 section_from = 1;
inline void Result_DataLocate::clear_section_from() {
  section_from_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::section_from() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.section_from)
  return section_from_;
}
inline void Result_DataLocate::set_section_from(::google::protobuf::uint32 value) {
  
  section_from_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.section_from)
}

// uint32 section_to = 2;
inline void Result_DataLocate::clear_section_to() {
  section_to_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::section_to() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.section_to)
  return section_to_;
}
inline void Result_DataLocate::set_section_to(::google::protobuf::uint32 value) {
  
  section_to_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.section_to)
}

// uint32 hash = 3;
inline void Result_DataLocate::clear_hash() {
  hash_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::hash() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.hash)
  return hash_;
}
inline void Result_DataLocate::set_hash(::google::protobuf::uint32 value) {
  
  hash_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.hash)
}

// uint32 divisor = 4;
inline void Result_DataLocate::clear_divisor() {
  divisor_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::divisor() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.divisor)
  return divisor_;
}
inline void Result_DataLocate::set_divisor(::google::protobuf::uint32 value) {
  
  divisor_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.divisor)
}

// -------------------------------------------------------------------

// Result

// int32 err_no = 1;
inline void Result::clear_err_no() {
  err_no_ = 0;
}
inline ::google::protobuf::int32 Result::err_no() const {
  // @@protoc_insertion_point(field_get:neb.Result.err_no)
  return err_no_;
}
inline void Result::set_err_no(::google::protobuf::int32 value) {
  
  err_no_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.err_no)
}

// bytes err_msg = 2;
inline void Result::clear_err_msg() {
  err_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Result::err_msg() const {
  // @@protoc_insertion_point(field_get:neb.Result.err_msg)
  return err_msg_.GetNoArena();
}
inline void Result::set_err_msg(const ::std::string& value) {
  
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Result.err_msg)
}
#if LANG_CXX11
inline void Result::set_err_msg(::std::string&& value) {
  
  err_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:neb.Result.err_msg)
}
#endif
inline void Result::set_err_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Result.err_msg)
}
inline void Result::set_err_msg(const void* value, size_t size) {
  
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Result.err_msg)
}
inline ::std::string* Result::mutable_err_msg() {
  
  // @@protoc_insertion_point(field_mutable:neb.Result.err_msg)
  return err_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_err_msg() {
  // @@protoc_insertion_point(field_release:neb.Result.err_msg)
  
  return err_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg != NULL) {
    
  } else {
    
  }
  err_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err_msg);
  // @@protoc_insertion_point(field_set_allocated:neb.Result.err_msg)
}

// int32 total_count = 3;
inline void Result::clear_total_count() {
  total_count_ = 0;
}
inline ::google::protobuf::int32 Result::total_count() const {
  // @@protoc_insertion_point(field_get:neb.Result.total_count)
  return total_count_;
}
inline void Result::set_total_count(::google::protobuf::int32 value) {
  
  total_count_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.total_count)
}

// int32 current_count = 4;
inline void Result::clear_current_count() {
  current_count_ = 0;
}
inline ::google::protobuf::int32 Result::current_count() const {
  // @@protoc_insertion_point(field_get:neb.Result.current_count)
  return current_count_;
}
inline void Result::set_current_count(::google::protobuf::int32 value) {
  
  current_count_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.current_count)
}

// repeated .neb.Record record_data = 5;
inline int Result::record_data_size() const {
  return record_data_.size();
}
inline void Result::clear_record_data() {
  record_data_.Clear();
}
inline ::neb::Record* Result::mutable_record_data(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Result.record_data)
  return record_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Record >*
Result::mutable_record_data() {
  // @@protoc_insertion_point(field_mutable_list:neb.Result.record_data)
  return &record_data_;
}
inline const ::neb::Record& Result::record_data(int index) const {
  // @@protoc_insertion_point(field_get:neb.Result.record_data)
  return record_data_.Get(index);
}
inline ::neb::Record* Result::add_record_data() {
  // @@protoc_insertion_point(field_add:neb.Result.record_data)
  return record_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Record >&
Result::record_data() const {
  // @@protoc_insertion_point(field_list:neb.Result.record_data)
  return record_data_;
}

// int32 from = 6;
inline void Result::clear_from() {
  from_ = 0;
}
inline ::google::protobuf::int32 Result::from() const {
  // @@protoc_insertion_point(field_get:neb.Result.from)
  return from_;
}
inline void Result::set_from(::google::protobuf::int32 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.from)
}

// .neb.Result.DataLocate locate = 7;
inline bool Result::has_locate() const {
  return this != internal_default_instance() && locate_ != NULL;
}
inline void Result::clear_locate() {
  if (GetArenaNoVirtual() == NULL && locate_ != NULL) {
    delete locate_;
  }
  locate_ = NULL;
}
inline const ::neb::Result_DataLocate& Result::_internal_locate() const {
  return *locate_;
}
inline const ::neb::Result_DataLocate& Result::locate() const {
  const ::neb::Result_DataLocate* p = locate_;
  // @@protoc_insertion_point(field_get:neb.Result.locate)
  return p != NULL ? *p : *reinterpret_cast<const ::neb::Result_DataLocate*>(
      &::neb::_Result_DataLocate_default_instance_);
}
inline ::neb::Result_DataLocate* Result::release_locate() {
  // @@protoc_insertion_point(field_release:neb.Result.locate)
  
  ::neb::Result_DataLocate* temp = locate_;
  locate_ = NULL;
  return temp;
}
inline ::neb::Result_DataLocate* Result::mutable_locate() {
  
  if (locate_ == NULL) {
    auto* p = CreateMaybeMessage<::neb::Result_DataLocate>(GetArenaNoVirtual());
    locate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:neb.Result.locate)
  return locate_;
}
inline void Result::set_allocated_locate(::neb::Result_DataLocate* locate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete locate_;
  }
  if (locate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      locate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, locate, submessage_arena);
    }
    
  } else {
    
  }
  locate_ = locate;
  // @@protoc_insertion_point(field_set_allocated:neb.Result.locate)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace neb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::neb::Mydis_RedisOperate_OPERATE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Mydis_RedisOperate_OPERATE_TYPE>() {
  return ::neb::Mydis_RedisOperate_OPERATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::neb::Mydis_DbOperate_Condition_E_RELATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Mydis_DbOperate_Condition_E_RELATION>() {
  return ::neb::Mydis_DbOperate_Condition_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION>() {
  return ::neb::Mydis_DbOperate_ConditionGroup_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::neb::Mydis_DbOperate_OrderBy_E_RELATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Mydis_DbOperate_OrderBy_E_RELATION>() {
  return ::neb::Mydis_DbOperate_OrderBy_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::neb::Mydis_DbOperate_E_QUERY_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Mydis_DbOperate_E_QUERY_TYPE>() {
  return ::neb::Mydis_DbOperate_E_QUERY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::neb::Result_E_RESULT_FROM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Result_E_RESULT_FROM>() {
  return ::neb::Result_E_RESULT_FROM_descriptor();
}
template <> struct is_proto_enum< ::neb::E_COL_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::E_COL_TYPE>() {
  return ::neb::E_COL_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mydis_2eproto
